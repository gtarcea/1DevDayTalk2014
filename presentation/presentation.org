#+TITLE: AngularJS and Go
#+AUTHOR: V. Glenn Tarcea
#+DATE: November 15th, 2014
#+OPTIONS: H:2
#+BEAMER_THEME: Hannover
#+BIND: org-beamer-frame-default-options "[allowframebreaks]"
#+BEAMER_COLOR_THEME: structure[RGB={44, 92, 132}]
#+LATEX_HEADER: \hypersetup{pdfauthor="V. Glenn Tarcea", pdftitle="AngularJS and Go", colorlinks, linkcolor=black, urlcolor=blue}
#+OPTIONSx: reveal_center:t reveal_progress:t reveal_history:nil reveal_control:t
#+OPTIONSx: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:1
#+REVEAL_HLEVEL: 2

* Introduction

** About Me

- Glenn Tarcea
- Senior Developer at University of Michigan
- Current Project: Materials Commons

** Materials Commons
    - Materials Commons is an online collaborative space for Metals Researchers
    - We have open sourced all the code for Materials Commons:
      - Go, Javascript, Java, Python, Erlang, C
    - You can find our code at:
      - https://github.com/materials-commons
      - https://github.com/prisms-center/materialscommons.org
    - There are alot of nice (if sometimes a bit rough) packages:
      - Erlang: gen stomp, resource discovery, process monitoring, OS interfaces
      - Go: Utilities, config, file transfer, FlowJS server
      - Javascript: AngularStomp
      - Java: DM3 Parser for Tika (not touched in a while)

** What this talk is about
    - This talk will cover creating a website using
      - Go and AngularJS
      - Websockets
      - REST
      - JWT
    - The site will allow for simple "collaboration"
      - By using broadcasts to keep each site in sync

** What this talk doesn't cover
    - This talk is not a Go or AngularJS tutorial
      - We will go over some aspects of both but will not spend a lot of time on the basics
    - It won't cover all aspects of the application
      - We will elide some details but you can refer to the sample app to get all the details

** Where to get the app
    - I've set up a Github repo that contains the working app
      - https://github.com/gtarcea/1DevDayTalk2014
    - The README.org goes over getting it running
      - In a nutshell:
        - Install go
        - Install godep (go get github.com/tools/godep)
        - make run
    - The intent of this app is to give you a starting point
      - It gives you a working JWT, Websocket, REST based application
      - With client side authentication
      - Automatic Reconnect
      - Broadcast to keep all connected clients updated
      - Close/Open socket and refresh state on logout/login
    - It looks simple but there is a lot going on
** Demo
   - Demonstrate
     - Login/Logout
     - Reconnect/Disconnect
     - Multiple Browsers staying in sync


* AngularJS Setup

** Overview
  - We'll cover the basics of setting up an angular app and configuring the needed packages
  - We use a few client libraries to make our lives easier
    - ui-router to give us multiple state based routes
    - ng-websocket for websocket communication
    - angular-jwt for easy JWT integration
    - Restangular for REST communication
  - We will cover configuring and integrating these packages

** Module References
- Set references to our app modules.
  - We break our app into different modules for the application pieces in AngularJS.
#+BEGIN_SRC js
  var App = App || {};
  App.Services = angular.module('app.services', []);
  App.Controllers = angular.module('app.cntrlrs', []);
  App.Filters = angular.module('app.filters', []);
  App.Directives = angular.module('app.directives', []);
  var app = angular.module('myapp', [
      "ui.router", "restangular",
      "app.services", "app.cntrlrs", "app.filters",
      "app.directives"
  ]);
#+END_SRC

** Configure our Routes
- We set up routes to pages and views in our system
#+BEGIN_SRC js
app.config(["$stateProvider", "$urlRouterProvider", "$httpProvider",
            "jwtInterceptorProvider",
            appConfig]);
function appConfig($stateProvider, $urlRouterProvider, $httpProvider,
                  jwtInterceptorProvider) {
    $stateProvider
        .state("login", {
            url: "/login",
            templateUrl: "app/login.html",
            controller: "loginController"
        })
        .state("users", {
            url: "/users",
            templateUrl: "app/users.html",
            controller: "usersController"
        })
        .state("users.add", {
            url: "/add",
            templateUrl: "app/add.html",
            controller: "addUserController"
        });

    // If the route isn't recognized goto /users
    $urlRouterProvider.otherwise("/users");
#+END_SRC

** Configure Authentication
    - To configure authentication we need to
      - Control access to protected areas of our app
      - Track user authentication
      - Setup JWT Headers for all REST calls
** Controlling Access
:PROPERTIES:
  :BEAMER_opt: shrink=10
:END:
#+BEGIN_SRC js
// appRun allows us to intercept different events while our
// application is running. Here it is used to control access
// to the application by requiring the user to login.
app.run(["$rootScope", "User", "$state", appRun]);
function appRun($rootScope, User, $state) {
    // $stateChangeStart is fired when a route change is starting.
    // Here we check if the user is already authenticatd. If they
    // aren't then we redirect them to the login page.
    $rootScope.$on('$stateChangeStart', function(event, toState, toParams) {
        if (!User.isAuthenticated()) {
            if (toState.url !== "/login") {
                // Cancel whatever route we were going to
                // and instead go to the login page.
                event.preventDefault();
                $state.go("login");
            }
        }
    });
}
#+END_SRC

** Configuring JWT
:PROPERTIES:
  :BEAMER_opt: shrink=10
:END:
- The following code is also in appConfig (where we also configured the routes)
- It configures $http (and Restangular) to include the JWT token in all REST calls
#+BEGIN_SRC js
  // The JWT token is stored in sessionStorage. When our
  // app starts up we explicitly clear the previous token.
  sessionStorage.setItem("token", null);

  // This interceptor will set the Authorization field
  // in the header with the JWT token.
  jwtInterceptorProvider.tokenGetter = function() {
      var token = sessionStorage.getItem("token");
      return token ? token : "";
  };
  $httpProvider.interceptors.push("jwtInterceptor");
#+END_SRC

** Configure Websockets
   - Websockets uses events
   - We only want to connect to the websocket after authentication
     - Unfortunately the Websocket spec doesn't allow us to add headers (JWT)
     - We could pass the token in the initial URL and then in each event to the server
       - We don't do this here but it is an option
   - ws is a convience service we wrote
#+BEGIN_SRC js
// Connect the socket
  $websocket.$new({
      url: ws.url(),
      reconnect: true,
      reconnectInterval: 500
  });

  // Wait on events
  var s = ws.get();
  s.$on("addeduser", function(user) {
      $timeout(function() {
          Users.add($scope.users, user);
      });
  });

#+END_SRC


* REST using Restangular

** Overview
- Restangular makes REST easy by
  - Providing Promises
  - Restangularizing your objects
    - Methods are attached to the returned object
    - You don't have to remember the
  - Easy to use API

** Example
   This example demonstrates retrieving and updating a user
#+BEGIN_SRC js
  var user = Restangular.all("users", 123);
  // change their name
  user.fullname = "New Name";
  user.post()
#+END_SRC

** Recall Sending JWT
   Recall that we configured the underlying $http service to include
   Authorization in the header with the JWT Token. Just to review:
#+BEGIN_SRC js
  // The JWT token is stored in sessionStorage. When our
  // app starts up we explicitly clear the previous token.
  sessionStorage.setItem("token", null);

  // This interceptor will set the Authorization field
  // in the header with the JWT token.
  jwtInterceptorProvider.tokenGetter = function() {
      var token = sessionStorage.getItem("token");
      return token ? token : "";
  };
  $httpProvider.interceptors.push("jwtInterceptor");
#+END_SRC

 Now whenever we make a Restangular call the header is automatically included.


* Services Overview
** Websocket Setup
#+BEGIN_SRC plantuml :file websockets.png
title Websocket Flow
activate Website
Website -> Server: Open
note right: Client opens a new websocket
activate Server
Server -> Listeners: Start Listeners
note right: New listeners are started for each connection
activate Listeners
Server <-- Listeners: Read/Write Go routines started
Website <-- Server: Accept Connection
note left: This would be a good point to send JWT Token
Website -> Server: Send Message
Website <-- Server: Broadcast Message
note left: Session established
deactivate Server
deactivate Website
deactivate Listeners
#+END_SRC

#+RESULTS:
[[file:websockets.png]]

** REST and JWT Authentication
#+BEGIN_SRC plantuml :file rest_jwt.png
title REST Request with JWT
activate Website
Website -> Server: Request
activate Server
Server -> JWTFilter: Request
note right: Validate JWT Token in header
Group Token Validates
  activate JWTFilter
  activate Container
  JWTFilter -> Container: Request
  Server <-- Container: REST Results
  Website <-- Server: REST Results
end
Group Invalid Token
  Server <-- JWTFilter: Not Authorized
  Website <-- Server: Not Authorized
end
deactivate Server
deactivate JWTFilter
deactivate Container
deactivate Website
#+END_SRC

#+RESULTS:
[[file:rest_jwt.png]]


* Go Routes Setup

** Overview

- Configure the Go HTTP server to handle:
  - Serving our website content
  - REST Calls
  - Websocket connections and broadcast
- Go has an HTTP interface that makes writing web servers and services very easy
  - This is one of the nicest pieces of using Go

** Go Web Server Setup

    - We'll point our web server at our apps directory
    - This will be our default route
       - The server will automatically pick up the index.html file
#+BEGIN_SRC go
  webdir := ...
  dir := http.Dir(webdir)
  http.Handle("/", http.FileServer(dir))
  addr := "localhost:8081"
  fmt.Println(http.ListenAndServe(addr, nil))
#+END_SRC

** REST Setup
- We'll use a nice REST extension package: go-restful
  - [[https://github.com/emicklei/go-restful]]
- Because this package uses HTTP interfaces we can use standard Go http to setup
#+BEGIN_SRC go
  container := ...

  // All REST calls come through a /api/... route.
  // We strip off /api before sending on to our
  // container this way the container doesn't
  // care about the prefix.
  http.Handle("/api/", http.StripPrefix("/api", container))
#+END_SRC
** Websocket Setup
- Continuing the HTTP interface theme the Websocket is also handled through the HTTP handler
- There is a bit more we have to do because its a long lived connection
- And we want to do broadcasts to all connected client
#+BEGIN_SRC go
 s := events.NewServer(hub)
 http.Handle("/ws", websocket.Handler(s.OnConnection))
#+END_SRC

* Go REST Service
** Overview
- Here we configure our REST service to handle different types of requests
- This example shows how we handle GET
- The syntax below means we can also use SWAGGER to document and expose our API
  - See:
    - Website: [[http://swagger.io/]]
    - Demo: [[http://petstore.swagger.wordnik.com/]]
#+BEGIN_SRC go
  ws := new(restful.WebService)
  ws.Path("/users").
          Consumes(restful.MIME_JSON).
          Produces(restful.MIME_JSON)

  ws.Route(ws.GET("").To(rest.RouteHandler(r.getAllUsers)).
          Doc("Retrieves all users").
          Writes([]schema.User{}))
#+END_SRC

** JWT Token Creation
- To create the tokens we need a private and public key
- We then have our server read the files
#+BEGIN_SRC sh
openssl genrsa -out app.rsa 1024
openssl rsa -in app.rsa -pubout > app.rsa.pub
#+END_SRC

#+BEGIN_SRC go
  // At this point we have read the public and private keys
  // Create the JWT Token
  token := jwt.New(jwt.GetSigningMethod("RS256"))
  token.Claims["ID"] = req.Username
  token.Claims["exp"] = time.Now().Add(time.Hour * 72).Unix()
  tokenStr, err := token.SignedString(r.privateKey)
  if err != nil {
          return err, nil
  }

  auth := schema.Auth{
          Username: req.Username,
          Token:    tokenStr,
  }
#+END_SRC

** JWT Token Verification
- We write an intercept filter that verifies the token
#+BEGIN_SRC go
// Setup the filter for the container
 f := filters.NewJWTFilter(publicKey, "/users/login")
 container := restful.NewContainer()
 container.Filter(f.Filter)
#+END_SRC

#+BEGIN_SRC go
  // Verify the token on each rest call
  func (f *jwtFilter) Filter(req *restful.Request, resp *restful.Response,
                             chain *restful.FilterChain) {
          // if the user is logging in for the first time then the
          // path will be f.loginPath. If that is the case then we just
          // go to the next filter because there is no token to
          // authenticate against.
          if req.Request.URL.Path != f.loginPath {

                  token, err := jwt.ParseFromRequest(req.Request, f.getKey)
                  if err != nil || !token.Valid {
                          fmt.Printf("invalid token for url %s: %s\n ", req.Request.URL.Path, err)
                          resp.WriteErrorString(http.StatusUnauthorized, "Not authorized")
                          return
                  }
          }
          chain.ProcessFilter(req, resp)
  }

  // Return the key jwt uses to validate a token.
  func (f *jwtFilter) getKey(token *jwt.Token) (interface{}, error) {
          return f.publicKey, nil
  }
#+END_SRC
** Service Implementation
#+BEGIN_SRC go
  func (r *usersResource) createUser(request *restful.Request,
          response *restful.Response, user schema.User) (error, interface{}) {

          var req userReq
          if err := request.ReadEntity(&req); err != nil {
                  return err, nil
          }
          u, err := r.users.CreateUser(req.Email, req.Fullname)
          return err, u
  }
#+END_SRC


* Go Websockets

** Overview
- Because websockets are long lived there is a bit more we need to do with them.
  - Setup 2 go routines for reading/writing
  - For our purposes we need to register with our broadcaster (EventHub)
#+BEGIN_SRC go
// OnConnection is called when a new websocket connection is made.
// It creates a persistent client connection and registers that
// connection with the hub. It it meant to be called by the
// websocket.Handler method.
func (s *Server) OnConnection(ws *websocket.Conn) {
	defer func() {
		ws.Close()
	}()

	client := NewClient(ws, s.hub)
	s.hub.Register(client)
	client.Listen()
}
#+END_SRC

* Conclusion
